<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="LibreOffice 4.0.2.2 (Linux)">
	<META NAME="CREATED" CONTENT="20090519;10431200">
	<META NAME="CHANGED" CONTENT="20150829;21020200">
	<META NAME="CHANGEDBY" CONTENT="TrungDung Nguyen">
	<META NAME="CHANGEDBY" CONTENT="TrungDung Nguyen">
	<STYLE TYPE="text/css">
	<!--
		@page { margin: 2.01cm }
		TD P { margin-bottom: 0.1cm }
		P { margin-bottom: 0.1cm }
		H3.cjk { font-family: "WenQuanYi Micro Hei" }
		H3.ctl { font-family: "Lohit Hindi" }
		PRE.ctl { font-family: "Lohit Hindi", monospace }
		H4.ctl { font-family: "Lohit Hindi" }
		CODE.ctl { font-family: "Lohit Hindi", monospace }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<P>********************13/04/2015****************************</P>
<P><B>COMPILATION: lexical-syntax-semantic (tu vung-cu phap-ngu
nghia) </B>
</P>
<P><A HREF="http://en.wikipedia.org/wiki/Compiler"><U><SPAN STYLE="font-weight: normal">http://en.wikipedia.org/wiki/Compiler</SPAN></U></A></P>
<H3 CLASS="western"><A NAME="Structure_of_a_compiler"></A><B>Structure
of a compiler: </B><SPAN STYLE="font-weight: normal">http://en.wikipedia.org/wiki/Compiler</SPAN></H3>
<P>Compilers bridge source programs in high-level languages with the
underlying hardware. A compiler verifies code syntax, generates
efficient object code, performs run-time organization, and formats
the output according to <A HREF="http://en.wikipedia.org/wiki/Assembler_%28computing%29">assembler</A>
and <A HREF="http://en.wikipedia.org/wiki/Linker_%28computing%29">linker</A>
conventions. A compiler consists of:</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><I>The front end</I>: Verifies
	syntax and semantics, and generates an <I>intermediate
	representation</I> or <I>IR</I> of the source code for processing by
	the middle-end. Performs <A HREF="http://en.wikipedia.org/wiki/Type_checking">type
	checking</A> by collecting type information. Generates errors and
	warning, if any, in a useful way. Aspects of the front end include
	lexical analysis, syntax analysis, and semantic analysis. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><I>The middle end</I>: Performs
	optimizations, including removal of useless or unreachable code,
	discovery and propagation of constant values, relocation of
	computation to a less frequently executed place (e.g., out of a
	loop), or specialization of computation based on the context.
	Generates another IR for the backend. 
	</P>
	<LI><P><I>The back end</I>: Generates the assembly code, performing
	<A HREF="http://en.wikipedia.org/wiki/Register_allocation">register
	allocation</A> in process. (Assigns <A HREF="http://en.wikipedia.org/wiki/Processor_register">processor
	registers</A> for the program variables where possible.) Optimizes
	target code utilization of the hardware by figuring out how to keep
	parallel <A HREF="http://en.wikipedia.org/wiki/Execution_unit">execution
	units</A> busy, filling <A HREF="http://en.wikipedia.org/wiki/Delay_slot">delay
	slots</A>. Although most algorithms for optimization are in <A HREF="http://en.wikipedia.org/wiki/NP_%28complexity%29">NP</A>,
	heuristic techniques are well-developed. 
	</P>
</UL>
<P><BR><BR>
</P>
<P><IMG SRC="800px-Compiler.svg.png" NAME="images1" ALIGN=LEFT WIDTH=567 HEIGHT=640 BORDER=0><BR CLEAR=LEFT><BR><BR>
</P>
<H3 CLASS="western"><IMG SRC="Xxx_Scanner_and_parser_example_for_C.gif" NAME="images2" ALIGN=LEFT WIDTH=567 HEIGHT=392 BORDER=0><BR CLEAR=LEFT><BR><BR>
</H3>
<H3 CLASS="western"><A NAME="Back_end"></A>Back end</H3>
<P>The term <I>back end</I> is sometimes confused with <A HREF="http://en.wikipedia.org/wiki/Code_generation_%28compiler%29"><I>code
generator</I></A> because of the overlapped functionality of
generating assembly code. Some literature uses <I><B>middle end</B></I>
to distinguish the generic analysis and optimization phases in the
back end from the machine-dependent code generators.</P>
<P>The main phases of the back end include the following:</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><A HREF="http://en.wikipedia.org/wiki/Compiler_analysis">Analysis</A>:
	This is the gathering of program information from the intermediate
	representation derived from the input; <A HREF="http://en.wikipedia.org/wiki/Data-flow_analysis">data-flow
	analysis</A> is used to build <A HREF="http://en.wikipedia.org/wiki/Use-define_chain">use-define
	chains</A>, together with <A HREF="http://en.wikipedia.org/wiki/Dependence_analysis">dependence
	analysis</A>, <A HREF="http://en.wikipedia.org/wiki/Alias_analysis">alias
	analysis</A>, <A HREF="http://en.wikipedia.org/wiki/Pointer_analysis">pointer
	analysis</A>, <A HREF="http://en.wikipedia.org/wiki/Escape_analysis">escape
	analysis</A>, etc. Accurate analysis is the basis for any compiler
	optimization. The <A HREF="http://en.wikipedia.org/wiki/Call_graph">call
	graph</A> and <A HREF="http://en.wikipedia.org/wiki/Control_flow_graph">control
	flow graph</A> are usually also built during the analysis phase. 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><A HREF="http://en.wikipedia.org/wiki/Compiler_optimization">Optimization</A>:
	the intermediate language representation is transformed into
	functionally equivalent but faster (or smaller) forms. Popular
	optimizations are <A HREF="http://en.wikipedia.org/wiki/Inline_expansion">inline
	expansion</A>, <A HREF="http://en.wikipedia.org/wiki/Dead_code_elimination">dead
	code elimination</A>, <A HREF="http://en.wikipedia.org/wiki/Constant_propagation">constant
	propagation</A>, <A HREF="http://en.wikipedia.org/wiki/Loop_transformation">loop
	transformation</A>, <A HREF="http://en.wikipedia.org/wiki/Register_allocation">register
	allocation</A> and even <A HREF="http://en.wikipedia.org/wiki/Automatic_parallelization">automatic
	parallelization</A>. 
	</P>
	<LI><P><A HREF="http://en.wikipedia.org/wiki/Code_generation_%28compiler%29">Code
	generation</A>: the transformed intermediate language is translated
	into the output language, usually the native <A HREF="http://en.wikipedia.org/wiki/Machine_language">machine
	language</A> of the system. This involves resource and storage
	decisions, such as deciding which variables to fit into registers
	and memory and the selection and scheduling of appropriate machine
	instructions along with their associated addressing modes (see also
	<A HREF="http://en.wikipedia.org/wiki/Sethi-Ullman_algorithm">Sethi-Ullman
	algorithm</A>). Debug data may also need to be generated to
	facilitate <A HREF="http://en.wikipedia.org/wiki/Debugging">debugging</A>.
		</P>
</OL>
<P><BR><BR>
</P>
<H1 LANG="en"><FONT SIZE=3><B>Interprocedural optimization</B></FONT></H1>
<P LANG="en" STYLE="font-weight: normal">IPO differs from other
compiler optimization because it analyzes the entire program; other
optimizations look at only a single function, or even a single block
of code</P>
<P><A HREF="http://en.wikipedia.org/wiki/Interprocedural_optimization"><SPAN STYLE="font-weight: normal">http://en.wikipedia.org/wiki/Interprocedural_optimization</SPAN></A></P>
<H3 CLASS="western"><BR><BR>
</H3>
<P><B>GNU Readline</B></P>
<P><A HREF="http://en.wikipedia.org/wiki/GNU_Readline"><SPAN STYLE="font-weight: normal">http://en.wikipedia.org/wiki/GNU_Readline</SPAN></A></P>
<P><SPAN STYLE="font-weight: normal">GNU Readline is a <A HREF="http://en.wikipedia.org/wiki/Software_library">software
library</A> that provides <A HREF="http://en.wikipedia.org/wiki/Line_editor">line-editing</A>
and history capabilities for <A HREF="http://en.wikipedia.org/wiki/Interactive_program">interactive
programs</A> with a <A HREF="http://en.wikipedia.org/wiki/Command-line_interface">command-line
interface</A></SPAN></P>
<P><BR><BR>
</P>
<P><B>Fonction de hachage (hash function): gperf </B>
</P>
<P><A HREF="https://www.gnu.org/software/gperf/"><SPAN STYLE="font-weight: normal">https://www.gnu.org/software/gperf/</SPAN></A></P>
<P><A HREF="http://fr.wikipedia.org/wiki/Fonction_de_hachage"><SPAN STYLE="font-weight: normal">http://fr.wikipedia.org/wiki/Fonction_de_hachage</SPAN></A></P>
<P><BR><BR>
</P>
<P><B>1.AST: </B>The end product of semantic parsing is an AST</P>
<P><A HREF="http://en.wikipedia.org/wiki/Abstract_syntax_tree">http://en.wikipedia.org/wiki/Abstract_syntax_tree</A></P>
<P><BR><BR>
</P>
<P><B>2.The LEXER: lexical analysis</B></P>
<P><SPAN STYLE="font-weight: normal">When it comes to implementing a
language, the first thing needed is the ability to process a text
file and recognize what it says. The traditional way to do this is to
use a “<A HREF="http://en.wikipedia.org/wiki/Lexical_analysis">lexer</A>”
(aka ‘scanner’) to break the input up into “tokens”. Each
token returned by the lexer includes a token code and potentially
some metadata (e.g. the numeric value of a number).</SPAN></P>
<P><A HREF="http://llvm.org/docs/tutorial/OCamlLangImpl1.html">http://llvm.org/docs/tutorial/OCamlLangImpl1.html</A></P>
<P><BR><BR>
</P>
<H1><FONT SIZE=3>Writing Your Own Toy Compiler Using Flex, Bison and
LLVM</FONT></H1>
<P><A HREF="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/6/">http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/6/</A></P>
<P><BR><BR>
</P>
<P>To summarize, the steps are as follows:</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><STRONG>Lexical Analysis with
	</STRONG><STRONG><EM>Flex</EM></STRONG>: Split input data into a set
	of tokens (identifiers, keywords, numbers, brackets, braces, etc.) 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><STRONG>Semantic Parsing with
	</STRONG><STRONG><EM>Bison</EM></STRONG>: Generate an AST while
	parsing the tokens. Bison will do most of the legwork here, we just
	need to define our AST. 
	</P>
	<LI><P><STRONG>Assembly with </STRONG><STRONG><EM>LLVM</EM></STRONG>:
	This is where we walk over our AST and generate byte/machine code
	for each node. As crazy as it sounds, this is probably the <EM>easiest</EM>
	step. 
	</P>
</OL>
<P>This means all we’re really doing is translating from one AST to
another</P>
<P><BR><BR>
</P>
<P>$ bison -d -o parser.cpp parser.y</P>
<P>$ lex -o tokens.cpp tokens.l</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P STYLE="page-break-before: always">********************15/04/2015****************************</P>
<P><B>BYTECODE</B></P>
<P>-Un code <B>intermédiaire</B> entre les instructions machines et
le code source, il n'est pas directement exécutable. Le bytecode
peut être créé à la volée et résider en mémoire (<A HREF="http://fr.wikipedia.org/wiki/Compilation_à_la_volée">compilation
à la volée</A>, JIT en anglais) ou bien résider dans un fichier,
généralement binaire qui représente le programme, tout comme un
fichier de <A HREF="http://fr.wikipedia.org/wiki/Code_objet">code
objet</A> (e.g.: .o, .obj, .pyc) produit par un compilateur.</P>
<P>-Il est appelé <I>bytecode</I> du fait de son format où chaque
instruction est codée en <SPAN STYLE="text-decoration: none">binaire</SPAN>.</P>
<P>-La <B>portabilité </B>: le même <I>bytecode</I> peut être
exécuté sur diverses plates<A HREF="http://fr.wikipedia.org/wiki/Plate-forme_%28informatique%29">-</A>formes
ou architectures pour lesquelles un interpréteur existe</P>
<P>Les performances des interpréteurs de <I>bytecode</I> sont
généralement bien meilleures que celles des interpréteurs de
scripts</P>
<P>De nombreux langages interprétés sont en fait compilés en
<I>bytecode</I> avant d'être exécutés par un interpréteur de
<I>bytecode</I>: e.g. Python</P>
<P>-Certains compilateurs, comme <A HREF="http://fr.wikipedia.org/wiki/LLVM">LLVM</A>,
utilisent le <I>bytecode</I> comme <A HREF="http://fr.wikipedia.org/wiki/Représentation_intermédiaire">représentation
intermédiaire</A> avant la transformation en code machine vers
l'architecture cible</P>
<P>-<I><B>JIT</B></I><I>: </I>traduise le <I>bytecode</I> en code
machine au fur et à mesure de l’exécution, cela permet
d’accélérer l’exécution sur les boucles ou les fonctions
appelées plusieurs fois tout en évitant de stocker sur disque ou de
transférer via les réseaux des données précompilées</P>
<P><BR><BR>
</P>
<P><B>INTERPRETE</B></P>
<P>-La plupart des interprètes utilisent des représentations
internes intermédiaires (arbres syntaxiques abstraits, ou même code
octet) et des traitements (analyses lexicale et syntaxique)
ressemblant à ceux des compilateurs</P>
<P>-Un certain nombre de langages informatiques sont aujourd'hui mis
en œuvre au moyen d'une <A HREF="http://fr.wikipedia.org/wiki/Machine_virtuelle_%28informatique%29">machine
virtuelle</A> applicative. Cette technique est à <I><U>mi-chemin
entre les interprètes tels que décrits ici et les compilateurs</U></I>.
Elle offre la portabilité des interprètes avec une bonne
efficacité. Par exemple, des portages de <I>Java, Lisp, Scheme,
Ocaml, Perl (Parrot), Python, Ruby, Lua, C#,</I> etc. sont faits <I>via</I>
une machine virtuelle.</P>
<P><BR><BR>
</P>
<P STYLE="page-break-before: always">********************28/04/2015****************************</P>
<P><B>SYMBOL TABLE</B></P>
<P><A HREF="http://en.wikipedia.org/wiki/Symbol_table">http://en.wikipedia.org/wiki/Symbol_table</A></P>
<P>a <B>symbol table</B> is a <A HREF="http://en.wikipedia.org/wiki/Data_structure">data
structure</A> used by a language translator such as a compiler or
interpreter, where each identifier in a program's source code is
associated with information relating to its declaration or appearance
in the source, such as its <B>type</B>, <B>scope</B> level and
sometimes its <B>location</B>.</P>
<P><BR><BR>
</P>
<P><B>HASH TABLE </B>
</P>
<P>http://en.wikipedia.org/wiki/Hash_table</P>
<P>https://www.gnu.org/software/gperf/</P>
<P>GNU gperf is a perfect hash function generator. For a given list
of strings, it produces a hash function and hash table, in form of C
or C++ code, for looking up a value depending on the input string</P>
<P><BR><BR>
</P>
<P><B>Difference between hash table &amp; stl map (C++):</B><BR>hash
table -&gt; data is tied to the key by a hash function<BR>stl map -&gt;
data is tied stored based on the value of the key in a balanced
binary search tree.&nbsp;<BR><BR>hash table -&gt; need to take
chaining into account if two different values have the same the same
key - key collision.&nbsp;<BR>hash table -&gt; values are not stored
in sorted order<BR>stl map -&gt; values are stored in sorted
order<BR><BR>hash table -&gt; lookup time is O(1), but dependent on
the hash function efficiency.&nbsp; High collision rate will increase
the lookup time.<BR>stl map -&gt; lookup time is O(lg n)<BR>same
applies for inserts<BR><BR>stl map is good to look up min and max
values, print values in sorted order and finding the closest element</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P STYLE="page-break-before: always">********************29/08/2015****************************</P>
<P><FONT COLOR="#0000ff"><FONT SIZE=4><B>C++ 2011 Rvalue &amp; Lvalue</B></FONT></FONT></P>
<P><FONT COLOR="#0000ff"><FONT SIZE=4><A HREF="http://thbecker.net/articles/rvalue_references/section_01.html"><FONT SIZE=3><SPAN STYLE="font-weight: normal">http://thbecker.net/articles/rvalue_references/section_01.html</SPAN></FONT></A></FONT></FONT></P>
<P><FONT COLOR="#0000ff"><FONT SIZE=4><A HREF="http://thbecker.net/articles/rvalue_references/section_03.html"><FONT SIZE=3><SPAN STYLE="font-weight: normal">http://thbecker.net/articles/rvalue_references/section_03.html</SPAN></FONT></A></FONT></FONT></P>
<H4 CLASS="western" STYLE="font-variant: normal; font-style: normal"><FONT COLOR="#000000"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=3>Rvalue
References</FONT></FONT></FONT></H4>
<PRE CLASS="western" STYLE="font-variant: normal; font-style: normal; font-weight: normal"><FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>void foo(X&amp; x); // lvalue reference overload</FONT></FONT></FONT>
<FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>void foo(X&amp;&amp; x); // rvalue reference overload</FONT></FONT></FONT>

<FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>X x;</FONT></FONT></FONT>
<FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>X foobar();</FONT></FONT></FONT>

<FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>foo(x); // argument is lvalue: calls foo(X&amp;)</FONT></FONT></FONT>
<FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>foo(foobar()); // argument is rvalue: calls foo(X&amp;&amp;)</FONT></FONT></FONT></PRE>
<TABLE WIDTH=680 CELLPADDING=5 CELLSPACING=1>
	<COL WIDTH=666>
	<TR>
		<TD WIDTH=666 STYLE="border: 1px double #808080; padding: 0.13cm">
			<P><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2><B>Note:</B>&nbsp;If
			you implement</FONT></FONT></P>
			<PRE CLASS="western" STYLE="margin-bottom: 0.5cm"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>void foo(X&amp;);</FONT></FONT></PRE><P>
			<FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>but not</FONT></FONT></P>
			<PRE CLASS="western" STYLE="margin-bottom: 0.5cm"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>void foo(X&amp;&amp;);</FONT></FONT></PRE><P>
			<FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>then of
			course the behavior is unchanged:&nbsp;</FONT></FONT><CODE CLASS="western"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>foo</FONT></FONT></CODE><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>&nbsp;can
			be called on l-values, but not on r-values. If you implement</FONT></FONT></P>
			<PRE CLASS="western" STYLE="margin-bottom: 0.5cm"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>void foo(X const &amp;);</FONT></FONT></PRE><P>
			<FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>but not</FONT></FONT></P>
			<PRE CLASS="western" STYLE="margin-bottom: 0.5cm"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>void foo(X&amp;&amp;);</FONT></FONT></PRE><P>
			<FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>then again,
			the behavior is unchanged:&nbsp;</FONT></FONT><CODE CLASS="western"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>foo</FONT></FONT></CODE><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>&nbsp;can
			be called on l-values and r-values, but it is not possible to make
			it distinguish between l-values and r-values. That is possible
			only by implementing</FONT></FONT></P>
			<PRE CLASS="western" STYLE="margin-bottom: 0.5cm"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>void foo(X&amp;&amp;);</FONT></FONT></PRE><P>
			<FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>as well.
			Finally, if you implement</FONT></FONT></P>
			<PRE CLASS="western" STYLE="margin-bottom: 0.5cm"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>void foo(X&amp;&amp;);</FONT></FONT></PRE><P>
			<FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>but neither
			one of</FONT></FONT></P>
			<PRE CLASS="western" STYLE="margin-bottom: 0.5cm"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>void foo(X&amp;);</FONT></FONT></PRE><P>
			<FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>and</FONT></FONT></P>
			<PRE CLASS="western" STYLE="margin-bottom: 0.5cm"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>void foo(X const &amp;);</FONT></FONT></PRE><P>
			<FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>then,
			according to the final version of C++11,&nbsp;</FONT></FONT><CODE CLASS="western"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>foo</FONT></FONT></CODE><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=2>&nbsp;can
			be called on r-values, but trying to call it on an l-value will
			trigger a compile error.</FONT></FONT></P>
		</TD>
	</TR>
</TABLE>
<PRE CLASS="western" STYLE="font-variant: normal; font-style: normal; font-weight: normal">
<FONT COLOR="#000000"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=3><U>Assignment operators</U></FONT></FONT></FONT>

<FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>X&amp; X::operator=(X const &amp; rhs); // classical implementation</FONT></FONT></FONT>
<A NAME="assignment_op"></A><FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>X&amp; X::operator=(X&amp;&amp; rhs)</FONT></FONT></FONT>
<FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>{</FONT></FONT></FONT>
<FONT COLOR="#000000">  <FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">// Move semantics: exchange content between this and rhs</SPAN></SPAN></FONT></FONT></FONT>
<FONT COLOR="#000000">  <FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">return *this;</SPAN></SPAN></FONT></FONT></FONT>
<FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>}</FONT></FONT></FONT></PRE><P STYLE="font-variant: normal; font-style: normal">
<FONT COLOR="#000000"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=3><U><SPAN STYLE="font-weight: normal">Implementing
an rvalue reference overload for the copy constructor is similar.</SPAN></U></FONT></FONT></FONT></P>
<PRE CLASS="western">
<FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>Base(Base const &amp; rhs); // non-move semantics</FONT></FONT></FONT>
<FONT COLOR="#000000"><FONT FACE="DejaVu Sans Mono, monospace"><FONT SIZE=2>Base(Base&amp;&amp; rhs); // move semantics</FONT></FONT></FONT></PRE><H4 CLASS="western" STYLE="font-variant: normal; font-style: normal">
<FONT COLOR="#000000"><FONT FACE="arial, helvetica, sans-serif"><FONT SIZE=3>Forcing
Move Semantics</FONT></FONT></FONT></H4>
<PRE CLASS="western" STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">T tmp(std::move(a));</SPAN></SPAN></FONT></FONT>
<FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">a = std::move(b); </SPAN></SPAN></FONT></FONT>
<FONT COLOR="#000000"><FONT SIZE=3><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">b = std::move(tmp);</SPAN></SPAN></FONT></FONT></PRE><P>
<BR><BR>
</P>
<P><BR><BR>
</P>
</BODY>
</HTML>